
    Related Work
    While many data flow analyses run backward, we found very little about backward-directed taint analysis in our literature research. 
    Most so-called backward taint analyses are targeted at reconstructing the full path either from a trace log
    (https://recon.cx/2013/slides/Recon2013-Richard20Johnson-Taint20Nobody20Got20Time20for20Crash20Analysis20-20slides.pdf (visited on 03/26/2021))
    (https://blog.trailofbits.com/2019/08/29/reverse-taint-analysis-using-binary-ninja/ (visited on 03/26/2021))
    (https://github.com/scotty-kdw/ARM-Analyzer/ (visited on 03/26/2021)) which is closer to the path builder of FlowDroid than our taint analysis.
    Besides those, we also found two taint analysis tools with a similar approach to ours.

    Lerch et al. contributed FlowTwist, a static taint analysis tool based on IFDS to detect confused deputy problems in libraries.
    A confused deputy is a legitimate program with more privileges tricked into misusing its authority by a malicious program.  They identify the cause of such as a combination of an integrity and confidentiality problem. 
    For the integrity part, the sinks perform sensitive operations and the sources are attacker-controlled. 
    In the confidentiality part, an attacker can read the sinks and sources provide sensitive data.
    A combination of both naturally gives a centered statement. 
    Now, the integrity sources and confidentiality sinks are way more frequent. 
    Thus they propose to solve the integrity part backward and the confidentiality part forward. 
    In contrast to FlowDroid, FlowTwist focuses on a specific taint analysis case and the applicability is relatively narrow. 

    Yan et al. proposed a vulnerability detection tool for PHP with a focus on web applications. They aim to detect typical web application vulnerabilities such as cross-site scripting and SQL injections using backward taint analysis. 
    Instead of relying on nesting the problem in proven data flow frameworks, they seemingly define their own data flow algorithm. The proposed algorithm traverses the basic blocks backward and copies the taints left after traversing a basic block to its predecessors. They do not try to reach a fixpoint; instead, they do not follow circular paths in the control-flow graph.
    They also emphasize their concept of "cleans": a predefined list of sanitization methods that kill the incoming taints. 
    In FlowDroid, the same is possible using taint wrappers and both shipped implementations support such a concept.
    A rationale for traversing backward, which is why we included it as related work, is not provided. Generally speaking, we doubt their tool is precise enough to be useful in practice.

    FlowDroid and also FlowTwist are based on IFDS. Now, IFDS is not the only way to realize taint analysis.  

    Synchronized pushdown systems (SPDS) by Späth et al. are an alternative to IFDS with access paths for modeling a precise context-, flow- and field-sensitive data flow analysis. 
    Similar to IFDS, a context-free grammar ensures the context-sensitivity. 
    In addition, another context-free grammar model the field-sensitivity.
    Contrary to access paths, this does not increase the domain and needs no -limiting to be fast enough in practice. 
    Then it computes the acceptance state of both pushdown automata to combine context- and field-sensitivity. 
    Now, in general, an automaton with two stacks is undecidable. The separation of the problems into two reachability problems and later combining the results is decidable. However, if both automata are in an acceptance state via different paths, the algorithm overapproximates the solution. 
    Their results look promising with a performance close to access paths with .
    Also, they could not observe the overapproximation in practice when performing typestate analysis.

    We did not find any ready-to-use taint analysis utilizing SPDS. 
    Currently in development is SWAN, a taint analysis for the Swift programming language based on SPDS(https://github.com/themaplelab/swan).

    Doop is a framework initially for pointer analysis. In contrast to others, it uses a declarative approach. Doop's frontend depends on Soot to create facts and encodes them in tables. The analyses are a declarative rule set written in Datalog. These rule sets are then fed into the datalog solver Soufflé(https://souffle-lang.github.io/). P/Taint extends Doop with a taint analysis. Doop is flow-insensitive and, thus, P/Taint as well.
