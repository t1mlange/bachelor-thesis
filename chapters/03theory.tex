\documentclass[../draft.tex]{subfiles}

\begin{document}
    \chapter{Theory}
    \section{Complexity of Data Flow Analysis}
    Explain where the run-time comes from.
    Depends the number of edge propagations
    \begin{itemize}
        \item "Branching factor" might be different for forwards/backwards, with some simple examples?
            \begin{itemize}
                \item  tainted = a + b. BW we don't know which was responsible for the tainted c $\rightarrow$ 2 new taints
                \item Simple assigments in a strict r-to-l order: a = b. FW {a, b} while BW we can kill a and just go with {b}
            \end{itemize}
        \item Lifetime of taints 
        \begin{itemize}
            \item Static taints are valid everywhere
            \item Best practise "sanitize just before displaying" might favor backwards
        \end{itemize}
        \item Number of taints
        \begin{itemize}
            \item There seems to be no correlation between source count and analysis time
            \item Probably also holds for sinks?
            \item There might be indicator for a single app whether it is better to start at sources or sinks
        \end{itemize}


    \end{itemize}
    \section{Flow Functions}
    In this section, we describe the behavior of the flow functions based on the Jimple language.

    \subsection{Normal Flow}
    Normal flow functions handle every statement that does not contain an \code{InvokeExpr}. The only case where a new taint can be produced is at an \code{AssignStmt}. It is straight-forward that this is true for statements like \code{IfStmt} if we recall \autoref{s:jimple}. The conditition is either an \code{UnopExpr} or \code{BinopExpr} of which both have no effect on the taint set. But we also skip over \code{IdentityStmt} even though they define a value. This is because we wait for the return site to map all parameters back into the callee.


    Now, lets consider the current statement is an \code{AssignStmt}. It consists of a variable, either a reference or a local, on the left side and an expression on the right side. Jimple ensures we just see one field reference at a time but to reduce the semi-formal rules, we take a shortcut here. So our assigment has the structure $x.f^n \leftarrow y.g^m$ with $n,m \in \{0,1\}$ modelling a possible field reference. Note that the taints can have an access path of an arbitrary length $k$ which is denoted as $h^k$.

    First, we look at the case when the access path matches exactly. Either we have a local ($n=0$) or a field reference ($n=1$) on the left. In the first case, the base of our taint needs to match and in the latter, the first field must also match. If the field references another heap object, we might encounter a non-empty access path $h^k$. This access path needs to be added to the newly created taint. We conclude:
    \begin{itemize}
        \item[] \textbf{Rule 1:} An incoming taint $t = x.f^n.h^k$ with $k \geq 0$ produces the outflowing taint set $T = \{y.g^m.h^k\}$.
    \end{itemize} 

    Next, we might have a whole object tainted. In this case, just the base needs to match:
    \begin{itemize}
        \item[] \textbf{Rule 2:} An incoming taint $t = x.*$ with $k \geq 0$ produces the outflowing taint set $T = \{y.g^m.*\}$.
    \end{itemize} 

    Lastly, the right side could also be tainted:
    \begin{itemize}
        \item[] \textbf{Rule 3:} An incoming taint $t = y.g^m.h^k$ with $k \geq 0$ produces the outflowing taint set $T = \{t\}$.
    \end{itemize}


    Whenever the taint neither matches on the left nor on the right side, we propagate it further untouched.

    \subsection{Call Flow}
    

    \subsection{Return Flow}

    \subsection{CallToReturn Flow}

\end{document}