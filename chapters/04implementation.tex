\documentclass[../draft.tex]{subfiles}

\begin{document}
    \chapter{Implementation}

    \section{Integration}
    \textsc{FlowDroid} is built to be extensible from to ground up. We wanted to reuse as much components of \textsc{FlowDroid} as possible. For the backwards analysis, we introduce unconditional taints at sinks and check for the matching access paths at sources. Facts are propagated through a reversed interprocedural control flow graph.

    The methods for retrieving sources and sinks from a SourceSinkManager have different signatures because only at one end the access paths must match and at the other the taints are unconditional. 
    We added the interface \code{IReversibleSourceSinkManager} extending the \code{ISourceSinkManager}. It enforces two additional methods:
    \begin{itemize}
        \item \code{SourceInfo getInverseSinkInfo(Stmt sCallSite, InfoflowManager manager)}
        \item \code{SinkInfo getInverseSourceInfo(Stmt sCallSite, InfoflowManager manager, AccessPath ap)}
    \end{itemize}
    \code{getInverseSinkInfo} returns the necessary information for introducing unconditional taints at sinks while \code{getInverseSourceInfo} also matches the access paths at sources.
    All three source sink managers \code{DefaultSourceSinkManager} for modelling Java, \code{AccessPathBasedSourceSinkManager} for modelling Android and \code{SummarySourceSinkManager} for summaries now implement the \code{IReversibleSourceSinkManager} interface.

    Due to the flow-sensitive aliasing of \textsc{FlowDroid} using IFDS, \textsc{FlowDroid} already provides an implementation of a reversed interprocedural control flow graph called \code{BackwardsInfoflowCFG}.
    For the core - the flow functions - we created two new components implementing \code{IInfoflowProblem}: the backwards infoflow problem and an alias problem. More on that in \autoref{s:problems}.

    To hide the fact that we internally swapped the sources and sinks, we also created a \code{BackwardsInfoflowResults} extending \code{InfoflowResults}. The implementation is quite simple. It overwrites the \code{addResult} implementations and reverses the constructed paths.

    The modularity of \textsc{FlowDroid} allowed us to easily use the newly created components. We created another implementation of \code{IInfoflow} responsible for initialization of those closely to the already existing default implementation \code{Infoflow}.

    \section{Problems}\label{s:problems}

    Explain TurnUnit, SkipUnit
    What the core problem tackles

    \section{Rules}
    Flow functions can get quite large, complicated to understand and hard to maintain \cite{Lerch2015}. To counteract this, \textsc{FlowDroid} outsources certain features into rules. These rules also provide the four flow functions and are applied in the corresponding flow function.

    \subsection{Backwards Sink Propagation Rule}


    \subsection{Backwards Source Propagation Rule}\label{s:sourcerule}

    \subsection{Backwards Array Propagation Rule}

    \subsection{Backwards Exception Propagation Rule}

    \subsection{Backwards Wrapper Propagation Rule}

    \subsection{Backwards Implicit Propagation Rule}
    Not implemented.
    % TODO

    \subsection{Backwards Strong Update Rule}

    \subsection{Backwards Clinit Rule}\label{s:clinitrule}
    \code{<clinit>} is a special method in the JVM and stands for class loader init. The function is generated by the compiler and can not be called explicitly. Examples of statements which get compiled into clinit can be seen in \autoref{lst:clinit_examples}. The invokation is implicit at the initialization phase of the class and is executed at most once for each class \footnote{\url{https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html\#jvms-2.9}}. 
    This behavior is modelled as an overapproximation in \textsc{FlowDroid}'s default call graph algorithm SPARK. SPARK adds an edge to \code{<clinit>} at each statement containing a \code{StaticFieldRef}, \code{StaticInvokeExpr} or \code{NewExpr} \footnote{\url{https://github.com/soot-oss/soot/blob/59931576784b910a7d38f81910b7313aa2feafea/src/main/java/soot/jimple/toolkits/callgraph/OnFlyCallGraphBuilder.java\#L969}}.
   
    \begin{figure}[ht]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{lstlisting}[gobble=16]
                class ClinitClass1 {
                    public static string str = source();
                }
            \end{lstlisting}
            \caption{static variable initialization}
            \label{lst:clinit_examples_a}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{lstlisting}[gobble=16]
                class ClinitClass2 {
                    static {
                        ClinitClass2.sink();
                    }
                }
            \end{lstlisting}
            \caption{static block}
            \label{lst:clinit_examples_b}
        \end{subfigure}
        \caption{Examples of statements being in \code{<clint>}}
        \label{lst:clinit_examples}
    \end{figure}


    The need for this rule is rooted in the IFDS solver of \textsc{FlowDroid}. The solver decides whether to use normal flow or call flow by calling \code{isCallStmt(Unit u)} on the interprocedural control flow graph generated by Soot. Internally, this method calls \code{containsInvokeExpr()} on the \code{Unit} object. \code{containsInvokeExpr()} for \code{AssignStmt} only returns true if the right hand side is an instance of \code{InvokeExpr}. Resulting, we miss the call to \code{<clinit>} for AssignStmts with NewExpr or StaticFieldRef on the right side.

    The Backwards Clinit Rule manually injects an edge to the \code{<clinit>} method in the infoflow solver when appropriate during the analysis. Also, it lessens the overapproximation of SPARK by carefully choosing whether to inject the edge. The rule works as follows:
    \begin{itemize}
        \item If the tainted static variable is a field of the methods class: Do not inject because we will at least encounter a \code{NewExpr} of the same class further in the call graph.
        \item Else if the tainted static variable matches the \code{StaticFieldRef} on the right hand side: Inject the edge because we can not be sure whether we see another edge to \code{<clinit>}.
        \item Else if the class of the tainted static variable matches the class of the \code{NewExpr}: Inject the edge because we can not be sure whether we see another edge to \code{<clinit>}.
    \end{itemize}
    This is still an overapproximation of course. A precise solution would require bookkeeping of the first occurence in the code of every class. 

    This rule has no equivalent in forwards analysis because in fowards analysis the problem is not as severe. As taints are introducted at sources, if the source statement is a static initialization as shown in \autoref{lst:clinit_examples_a}, the propagation starts inside the \code{<clinit>} method. The solver has a \code{followReturnsPastSeeds} option which propagates return flows for unbalanced problems, for example when the taint was introducted inside a method and therefore there was no incoming flow. This allows the forwards analysis to detect leaks originated from static variable initializations but misses leaks inside static blocks as shown in \autoref{lst:clinit_examples_b}.

    \subsection{Other Rules}
    Skip System Class Rule and Stop After First K Flows Rule are not direction-dependent. Both are shared with the forwards search and therefore use the existing implementation in \textsc{FlowDroid}.
    
    Typing Propagation Rule has no backwards equivalent. We decided to implement type checking in the infoflow problem instead.



    \section{Code Optimizer}
    Before starting the analysis, \textsc{FlowDroid} applies code optimization to the interprocedural call graph. By default, dead code elimination and within constant value propagation is performed. Those are also applied before backwards analysis but we needed another code optimizer to handle an edge case in backwards analysis.

    \subsection{AddNOPStmts}
    First, take a look at \code{StatictTestCode#static2Test} in \autoref{lst:static2TestJava}. The method and entry point \code{static2Test} is static and does not have any parameters. Same is true for the source method \code{TelephonyManager#getDeviceId}. Due to the first condition, \code{static2Test} has no identity statements and because of the second  condition there are also no assign statements before the source statement in Jimple. Therefore the source statement is the first statement in the graph. 
    Next, a detail of \textsc{FlowDroid}'s IFDS solver is important. The Return and CallToReturn flow function is only applied if a return site is available \cite{Arzt2017PhD}.
    When searching backwards, the source statement is the last statement and thus has no return sites. Now recall \autoref{s:sourcerule}, taints flowing into sources are registered in the CallToReturn flow function. Altogether, leaks can not be found if the source statement is the first statement.

    Moving the detection of incoming taints flows into sources from the CallToReturn to the Call flow function was not an option because by default source methods are not visited. 
    Our solution is to just add a NOP statement in such cases. This saves us from introducing new edge cases inside the flow functions which are already complex enough. Due to the entry points being known beforehand, the overhead is negligible.

    \begin{figure}
        \centering
        \begin{lstlisting}[gobble=12]
            public static void static2Test() {
                String tainted = TelephonyManager.getDeviceId();
                ClassWithStatic static1 = new ClassWithStatic();
                static1.setTitle(tainted);
                ClassWithStatic static2 = new ClassWithStatic();
                String alsoTainted = static2.getTitle();
                
                ConnectionManager cm = new ConnectionManager();
                cm.publish(alsoTainted);
            }
        \end{lstlisting}
        \caption{static2Test Java Code}
        \label{lst:static2TestJava}
    \end{figure}

\end{document}