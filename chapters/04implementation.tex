\documentclass[../draft.tex]{subfiles}

\begin{document}
    \chapter{Implementation}
    This chapter describes the details of our backward-directed implementation and how we integrated it into \textsc{FlowDroid}.

    \section{Integration}
    \textsc{FlowDroid} is built to be extensible from to ground up. We wanted to reuse as many components of \textsc{FlowDroid} as possible. 
    
    First, we needed a backward interprocedural control-flow graph. \textsc{FlowDroid} already contained one for the on-demand aliasing, which only missed the \code{notifyMethodChanged()} method.
    Next, we need to introduce unconditional taints at sinks and check for the matching access paths at sources.
    The methods for retrieving sources and sinks from a Source Sink Manager have different signatures because, in the forward analysis, access paths only have to match at sinks. We added the interface \code{IReversibleSourceSinkManager} extending the \code{ISourceSinkManager}. It enforces two additional methods:
    \begin{itemize}
        \item \code{SourceInfo getInverseSinkInfo(Stmt sCallSite,}\\
              \phantom{\code{ceInfo getInverseSinkInfo(}}\code{InfoflowManager manager)}
        \item \code{SinkInfo getInverseSourceInfo(Stmt sCallSite,}\\
              \phantom{\code{Info getInverseSourceInfo(}}\code{InfoflowManager manager, AccessPath ap)}
    \end{itemize}
    \code{getInverseSinkInfo} returns the necessary information for introducing unconditional taints at sinks, while \code{getInverseSourceInfo} also matches the access paths at sources.
    All source sink managers needed for the data flow analysis now implement the corresponding interface.
    Note that reversible source sink managers currently do not support the one-source-at-a-time mode.

    For the core flow functions, we created two new classes implementing \code{IInfoflowProblem}. \code{BackwardsInfoflowProblem} implements the flow functions described in \autoref{s:flowfunctions}. We also refer to this as the main analysis. Additional language features are sourced out into rules which are informally described in \autoref{s:rules}. The second class is \code{BackwardsAliasProblem} which is responsible for the on-demand forward alias analysis. We describe the on-demand aliasing in greater detail in \autoref{s:aliasing}.

    After the analysis, the path builder constructs a path out of the leaked taint and its predecessors. Because the path builder expects a forward-built taint, the path ends up being the wrong way round. To hide the fact that we internally searched backward, we also created a \code{BackwardsInfoflowResults} extending \code{InfoflowResults}. The implementation is quite simple. It overwrites only the \code{addResult} implementations to swap the start and end. If full path reconstruction is enabled, it also reverses the path in between.

    \section{Flow-Sensitive Alias Analysis}\label{s:aliasing}
    \textsc{FlowDroid} offers multiple aliasing strategies.
    In this work, we focus on flow-sensitive alias analysis. The analysis is another IFDS problem. However, this time, it is a forward-directed IFDS analysis using flow function with aliasing rules. The main analysis invokes the alias analysis on-demand when it discovers an alias. The alias analysis runs independent from the main analysis and later injects found aliases back into the main analysis.

    Note that pointer analysis itself is a non-distributive problem \cite{Arzt2017PhD, Spaeth2016}. Nonetheless, the alias analysis is encoded in IFDS and we just accept the possibly imprecise results due to the overapproximation. Not using the intertwined alias analysis is too imprecise and the cases of overapproximation are rare in practice \cite{Arzt2017PhD}.

    \begin{figure}[ht]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{adjustbox}{max width=\columnwidth}
                \begin{lstlisting}[gobble=20]
                    void aliasRule1() {
                        A a = b;
                        b.str = source();
                        sink(a.str);
                    }
                \end{lstlisting}
            \end{adjustbox}
            \caption{Example for alias analysis initiated by rule 1}
            \label{lst:aliasex_a}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{adjustbox}{max width=\columnwidth}
                \begin{lstlisting}[gobble=20]
                    void aliasRule3() {
                        A a = b;
                        a.str = source();
                        sink(b.str);
                    }
                \end{lstlisting}
            \end{adjustbox}
            \caption{Example for alias analysis initiated by rule 3}
            \label{lst:aliasex_b}
        \end{subfigure}
        \caption{Normal flow Aliasing examples}
        \label{lst:aliasex}
    \end{figure}

    \paragraph{Handover between the analyses}
    The main analysis discovers aliases at assignments. Consider \autoref{lst:aliasex} where two different cases are displayed. On the left is a normal flow according to rule 1. In line 2, the in taint \code{a.str} produces the outcoming taint \code{b.str}. Because the assignment type is a heap type, the backward analysis now recognizes that it possibly missed updates to \code{b.str} below of line 2. It invokes the alias analysis with \code{b.str}. On the right is a normal flow according to rule 3. This time the assignment in line 2 is swapped. The main analysis leaves the incoming taint \code{b.str} untouched but notices \code{a} aliases \code{b} below line 2, hence invoking the alias analysis with \code{a.str}.
    
    The alias analysis searches for missed updates. If the analysis found an update, e.g., the taint is on the left side of the assignment, the analysis injects an edge to the statement with the taint into the main analysis' worklist. Consider again \autoref{lst:aliasex_a}. In line 3, the alias analysis encounters the tainted \code{b.str} on the left side. At this point, \code{b.str} gets handed back to the main analysis, following the missed update to find a possible leak. In this case, the leak happens right away.

    \begin{figure}[ht]
        \centering
        \begin{adjustbox}{max width=\columnwidth}
            \begin{lstlisting}[gobble=16]
                void turnStmtNeeded() {
                    A a = b;
                    String str = b.str;
                    a.str = source();
                    sink(str);
                }
            \end{lstlisting}
        \end{adjustbox}
        \caption{Aliasing example with turn unit}
        \label{lst:turnunit}
    \end{figure}

    \paragraph{Maintaining Flow Sensitivity}
    Arzt solved this in the existing forward implementation using an activation unit. This statement marks the update at which the alias gets tainted and can leak at sinks. This concept does not work for our backward implementation as the alias analysis traverses forward where a write to a variable means a leak. Thus we introduce the turn unit. The turn unit holds the last non-aliasing assignment. When a taint reaches its turn unit in the aliasing analysis, the analysis kills the taint. Consider \autoref{lst:turnunit}. The introduced taint \code{str} in line 6 also has line 6 as a turn unit. In line 4, a non-aliasing assignment happens. In line 2, the alias analysis starts for \code{a.str}. Without the turn unit, the taint would pass line 3. Further in line 5, the taint is handed to the main analysis. The main analysis then reports a leak. With the turn unit, the alias analysis kills the taint in line 4, preventing the false positive. 
    
    \begin{figure}[ht]
        \centering
        \begin{adjustbox}{max width=\columnwidth}
            \begin{lstlisting}[gobble=16]
                void foo() {
                    // [...]
                    bar(someObject1);
                    sink(someObject1);

                    bar(someObject2);
                    sink(someObject2);
                }
            \end{lstlisting}
        \end{adjustbox}
        \caption{Summaries with Turn Units}
        \label{lst:turnunitsum}
    \end{figure}

    The turn unit is a new field in the \code{Abstraction} class, which is representing a taint. A possible drawback of the backward analysis could be the reusability of the IFDS summaries. Because the turn unit is part of the taint, IFDS treats equal taints with different turn units as if they have a different context. Consider \autoref{lst:turnunitsum}. \code{str1} and \code{str2} are equal taints, but one has the turn unit at line 7 while the other one has the turn unit set to line 4. Let us assume IFDS already traversed the call to \code{bar(someObject2);} in line 6 and created a summary from it. Later, it observes the same callee but with \code{someObject1} as an argument. Though, because the turn units differ, IFDS can not apply the already existing summary. In this case, applying the summary would not be harmful. However, if the turn unit is inside the callee or the transitive callees, we would effectively lose the flow sensitivity as the turn unit is ignored.

    \section{Rules}\label{s:rules}
    Flow functions can get quite large, complicated to understand and hard to maintain \cite{Lerch2015}. To counteract this, \textsc{FlowDroid} outsources certain features into rules. These rules also implement the four flow functions and are applied in the main analysis's corresponding flow function.
    In this section, we describe our implementation and informally state the rule behavior.

    \subsection{Source \& Sink Propagation Rule}\label{s:sourcerule}
    In backward analysis, sources act like sinks and vice versa. Thus, the Source Propagation Rule records taints flowing into sources and the Sink Propagation Rule unconditionally introduces taints at sinks requiring an \code{IReversibleSourceSinkManager}.

    Notably, the \code{DefaultSourceSinkManager} assumes the return value to be tainted. Only if the return value is ignored or the method has no return value, the base object is assumed to be tainted while at sinks base object and parameters are leaked \cite{Arzt2017PhD}. Thus, starting at sinks results in more taints per statement than in forwards analysis. Recall \autoref{s:complexity}, Arzt's evaluation has shown that the initial source count does not correlate with the runtime, which implies that this should be is insignificant on real-world apps.

    \subsection{Backwards Array Propagation Rule}
    In \textsc{FlowDroid}, array taints are overapproximated by only distinguishing contents and length but not elements. Meaning if one element of an array is tainted, \textsc{FlowDroid} considers all elements tainted. 
    Indices are often computed at runtime and thus not available for a static analysis without applying another analysis beforehand. So, the approximation is not as severe because we could only track constant indices regardless. 
    Furthermore, distinguishing elements would increase the domain even more, subsequently increasing the runtime \cite{Arzt2017PhD}.  

    The Array Propagation Rule handles \code{ArrayNewExpr}, \code{LengthExpr} and \code{ArrayRef} on the right-hand side.

    \begin{itemize}
        \item \textbf{Array Rule 1}: If the left side's length is tainted and the right side is an \code{ArrayNewExpr}, the outcoming taint is the size local of the \code{ArrayNewExpr}.
        \item  \textbf{Array Rule 2}: If the left side is tainted and the right side is a \code{LengthExpr}, the outcoming taint is the operand of the \code{LengthExpr} with only its length tainted.
        \item \textbf{Array Rule 3:} If the left side is tainted and the right side is an \code{ArrayRef}, the outcoming taint is the array base with only its content tainted.
    \end{itemize}

    The overapproximation of arrays also implies that array taints can not be killed if the left side is an \code{ArrayRef}.

    \subsection{Backwards Exception Propagation Rule}
    The backwards analysi first finds a catched exception in the form of \code{\$someVar := @caughtexception}. Then it sets an exception flag at the taint and propagates the taint onwards. The subsequent propagation then finds the corresponding throw statement.
    \begin{itemize}
        \item \textbf{Exception Rule 1}: On a caught exception expression, derive a new taint with an exception flag set.
        \item \textbf{Exception Rule 2}: If a taint with the exception flag set occurs at a \code{ThrowStmt}, derive taint the operand of the \code{ThrowStmt}. 
    \end{itemize}

    The second rule is present in Call and Normal Flow because the throw statement can be inside the same method or in a callee.

    \subsection{Backwards Wrapper Propagation Rule}
    The implementation of this rule is similar to the existing implementation. A tainted returned value also needs to be passed into the taint wrapper because of the backward direction. The rule calls \code{getInverseTaints()} and thus requires the taint wrapper to implement the \code{IReversibleTaintWrapper} interface .

    % \subsection{Backwards Implicit Propagation Rule}
    % Not implemented.

    \subsection{Backwards Strong Update Rule}
    Until now, we always assumed that a taint is only affected if the variable occurs in a statement. 
    However, with aliasing, this gets quite more complicated. 
    A taint could not match the left side and, thus, is propagated over the statement according to the default rule of normal flow, but the taint is an alias of the left side and should have been killed. 
    Also, we can not just link aliases to taints for such strong updates because that would violate the flow functions' distributiveness property.
    
    In this case, \textsc{FlowDroid} falls back to Soot's must-aliasing analysis. However, the must-aliasing analysis is only intraprocedural. Thus, strong updates split over methods are not detected and produce a false positive.
    
    Backward, the first observed update is the correct one. We treat a must-alias like a regular match:
    \begin{itemize}
        \item \textbf{Strong Update Rule}: If the incoming taint must-aliases the left side, then apply the normal flow rules just as if the left side was tainted. 
    \end{itemize}

    \subsection{Backwards Clinit Rule}\label{s:clinitrule}
    \code{<clinit>} is a special method in the JVM and stands for class loader init. The compiler generates the method and calls it implicitly. Examples of statements that get compiled into clinit are in \autoref{lst:clinit_examples}. The invokation is implicit at the class's initialization phase and is executed at most once for each class\footnote{\url{https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html\#jvms-2.9}}. 
    SPARK, which default call graph algorithm in \code{FlowDroid}, overapproximates the \code{<clinit>} behavior. It adds an edge to \code{<clinit>} at each statement containing a \code{StaticFieldRef}, \code{StaticInvokeExpr} or \code{NewExpr}
    \footnote{\url{https://github.com/soot-oss/soot/blob/59931576784b910a7d38f81910b7313aa2feafea/src/main/java/soot/jimple/toolkits/callgraph/OnFlyCallGraphBuilder.java\#L969}}.
   
    \begin{figure}[ht]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{lstlisting}[gobble=16]
                class ClinitClass1 {
                    public static string str = source();
                }
            \end{lstlisting}
            \caption{static variable initialization}
            \label{lst:clinit_examples_a}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{lstlisting}[gobble=16]
                class ClinitClass2 {
                    static {
                        ClinitClass2.sink();
                    }
                }
            \end{lstlisting}
            \caption{static block}
            \label{lst:clinit_examples_b}
        \end{subfigure}
        \caption{Examples of statements being in \code{<clinit>}}
        \label{lst:clinit_examples}
    \end{figure}


    The need for this rule is rooted in the IFDS solver of \textsc{FlowDroid}. The solver decides whether to use Normal Flow or Call Flow by calling \code{isCallStmt(Unit u)} on the interprocedural control-flow graph generated by Soot. Internally, this method calls \code{containsInvokeExpr()} on the \code{Unit} object. \code{containsInvokeExpr()} for \code{AssignStmt} only returns true if the right-hand side is an instance of \code{InvokeExpr}. Consequently, the calls to \code{<clinit>} from \code{AssignStmt}s with \code{NewExpr} or \code{StaticFieldRef} on the right side are missed.

    The Backwards Clinit Rule manually injects an edge to the \code{<clinit>} method in the infoflow solver when appropriate during the analysis. Also, it lessens the overapproximation of SPARK by carefully choosing whether to inject the edge. The rule works as follows:
    \begin{itemize}
        \item \textbf{Clinit Rule 1}: If the tainted static variable is a field of the methods class, do not inject because we will at least encounter a \code{NewExpr} of the same class further in the call graph.
        \item \textbf{Clinit Rule 2}: Else if the tainted static variable matches the \code{StaticFieldRef} on the right hand side: Inject the edge because we can not be sure whether we see another edge to \code{<clinit>}.
        \item \textbf{Clinit Rule 3}: Else if the class of the tainted static variable matches the class of the \code{NewExpr}: Inject the edge because we can not be sure whether we see another edge to \code{<clinit>}.
    \end{itemize}
    The behavior is still an overapproximation, of course. A more precise solution would require bookkeeping of every class's last observation equal to the first occurrence in the code. 

    In the existing implementation, there is no such explicit. As taints are introduced at sources, if the source statement is a static initialization as shown in \autoref{lst:clinit_examples_a}, the propagation starts inside the \code{<clinit>} method. The solver has a \code{followReturnsPastSeeds} feature which propagates return flows for unbalanced problems, for example when the taint was introduced inside a method and therefore there was no incoming flow. This allows the forward analysis to detect leaks originated from static variable initializations but misses leaks inside static blocks as shown in \autoref{lst:clinit_examples_b}.

    \subsection{Other Rules}
    Skip System Class Rule and Stop After First K Flows Rule are not direction-dependent. Both are shared with the forwards search and therefore use the existing implementation in \textsc{FlowDroid}.
    
    % Typing Propagation Rule has no backwards equivalent. We decided to implement type checking in the infoflow problem instead.

    \section{Other Components}
    \subsection{Taint Wrappers}\label{s:taintwrapper}
    \textsc{FlowDroid} already has an interface \code{IReversibleTaintWrapper} for taint wrappers providing inversed summaries. The \code{SummaryTaintWrapper} using StubDroid's summaries already implemented this interface. For the \code{EasyTaintWrapper}, we contributed the inverse implementation. Its implementation follows simple rules which cover most cases\cite{Arzt2017PhD}. The rules are inverted to:
    \begin{itemize}
        \item If the return value is tainted, taint the object and the parameters.
        \item If the base object is tainted, taint all parameters.
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \begin{adjustbox}{max width=\columnwidth}
            \begin{lstlisting}[gobble=16]
                char[] tainted = source();
                StringBuilder sb = new StringBuilder();
                sb.append(tainted, offset, len);
                sb.append("untainted");
                sink(sb.toString());
            \end{lstlisting}
        \end{adjustbox}
        \caption{Easy Taint Wrapper Example}
        \label{lst:etw}
    \end{figure}

    Note that these simple rules are disadvantageous for the backward direction the more parameters a method has. Consider the code snippet in \autoref{lst:etw}, especially line 3. Forwards, 
    \code{tainted} is the incoming taint and the \code{EasyTaintWrapper} produces the taint set \code{\{tainted, sb\}}. Backward, the incoming taint is \code{sb} and the taint wrapper produces four taints \code{\{sb, tainted, offset, len\}}. Luckily, most methods supported by the \code{EasyTaintWrapper} have less than three arguments.

    \subsection{Native Call Handler}
    The native call handler of \textsc{FlowDroid} handles two methods: \code{System#arraycopy} and \code{reflect.Array#newArray}.
    The handling of \code{System#arraycopy} is direction-dependent. Thus, we adapted the existing implementation and reversed the logic of \code{System#arraycopy} to reflect the analysis direction.

    \subsection{Code Optimizer: AddNOPStmts}
    Before starting the analysis, \textsc{FlowDroid} applies code optimization to the interprocedural call graph. By default, dead code elimination and within constant value propagation is performed. Those are also applied before backward analysis,but we needed another code optimizer to handle an edge case in backward analysis.

    First, consider the \code{static2Test} test case in the \code{StatictTestCode} class of \textsc{FlowDroid} in \autoref{lst:static2TestJava}. The method is also the entry point for the analysis, is static and does not have any parameters. The same is true for the source \code{TelephonyManager#getDeviceId}. Due to the first condition, \code{static2Test} has no identity statements and because of the second condition, there are also no assign statements before the source statement in Jimple. Therefore the source statement is the first statement in the graph. 
    Next, a detail of \textsc{FlowDroid}'s IFDS solver is important. The Return and CallToReturn flow function is only applied if a return site is available.
    When traversing backward, the source statement is the last and thus has no return sites. Now, the taints flowing into source methods are registered in the Call To Return flow function. Altogether, leaks are missed if the source statement is the first statement.

    Moving the detection of incoming taints flows into sources from the CallToReturn to the Call flow function was not an option because by default source methods are not visited and changing this would require multiple changes in the existing implementation and also ours. 
    Our solution is to add a NOP statement in such cases before the analysis. Due to the entry points being known beforehand, the overhead is nearly zero.

    \begin{figure}[ht]
        \centering
        \begin{subfigure}[b]{\textwidth}
            \begin{lstlisting}[gobble=16]
                public static void static2Test() {
                    String tainted = TelephonyManager.getDeviceId();
                    ClassWithStatic static1 = new ClassWithStatic();
                    static1.setTitle(tainted);
                    ClassWithStatic static2 = new ClassWithStatic();
                    String alsoTainted = static2.getTitle();
                    
                    ConnectionManager cm = new ConnectionManager();
                    cm.publish(alsoTainted);
                }
            \end{lstlisting}
            \caption{Java}
        \end{subfigure}
        \qquad
        \begin{subfigure}[b]{\textwidth}
            \begin{lstlisting}[language=Jimple, gobble=16]
                public static void static2Test() {
                    tainted = staticinvoke <soot.jimple.infoflow.test.android.TelephonyManager: java.lang.String getDeviceId()>(); // Line 2 in (a)

                    // [...]
            
                    virtualinvoke cm.<soot.jimple.infoflow.test.android.ConnectionManager: void publish(java.lang.String)>(alsoTainted); // Line 9 in (a)

                    return;
                }
            \end{lstlisting}
            \caption{Jimple}
        \end{subfigure}
        \caption{static2Test Code}
        \label{lst:static2TestJava}
    \end{figure}
\end{document}