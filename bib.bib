% Encoding: UTF-8

@Article{Spaeth2019,
  author   = {Späth, Johannes and Ali, Karim and Bodden, Eric},
  journal  = {Proceedings of the ACM on Programming Languages},
  title    = {Context-, flow-, and field-sensitive data-flow analysis using synchronized {Pushdown} systems},
  year     = {2019},
  month    = jan,
  pages    = {1--29},
  volume   = {3},
  abstract = {Precise static analyses are context-, field- and flow-sensitive. Context- and field-sensitivity are both expressible as context-free language (CFL) reachability problems. Solving both CFL problems along the same data-flow path is undecidable, which is why most flow-sensitive data-flow analyses over-approximate field-sensitivity through k-limited access-path, or through access graphs. Unfortunately, as our experience and this paper show, both representations do not scale very well when used to analyze programs with recursive data structures.
Any single CFL-reachability problem is efficiently solvable, by means of a pushdown system. This work thus introduces the concept of synchronized pushdown systems (SPDS). SPDS encode both procedure calls/returns and field stores/loads as separate but “synchronized” CFL reachability problems. An SPDS solves both individual problems precisely, and approximation occurs only in corner cases that are apparently rare in practice: at statements where both problems are satisfied but not along the same data-flow path.
SPDS are also efficient: formal complexity analysis shows that SPDS shift the complexity from {\textbar}F{\textbar}3k under k-limiting to {\textbar}S{\textbar}{\textbar}F{\textbar}², where F is the set of fields and S the set of statements involved in a data-flow. Our evaluation using DaCapo shows this shift to pay off in practice: SPDS are almost as efficient as k-limiting with k=1 although their precision equals k=∞. For a typestate analysis SPDS accelerate the analysis up to 83× for data-flows of objects that involve many field accesses but span rather few methods.
We conclude that SPDS can provide high precision and further improve scalability, in particularly when used in analyses that expose rather local data flows.},
  doi      = {10.1145/3290361},
  file     = {ResearchGate Link:https\://www.researchgate.net/publication/330152854_Context-_flow-_and_field-sensitive_data-flow_analysis_using_synchronized_Pushdown_systems:},
}

@InProceedings{Lam2011,
  author     = {Lam, Patrick and Bodden, Eric and Lhotak, Ondrej and Hendren, Laurie},
  title      = {The {Soot} framework for {Java} program analysis: a retrospective},
  year       = {2011},
  month      = oct,
  language   = {en},
  shorttitle = {The {Soot} framework for {Java} program analysis},
  url        = {http://www.bodden.de/pubs/lblh11soot.pdf},
  urldate    = {2021-03-11},
}

@InProceedings{Rasthofer2014,
  author    = {Rasthofer, Siegfried and Arzt, Steven and Bodden, E.},
  booktitle = {{NDSS}},
  title     = {A {Machine}-learning {Approach} for {Classifying} and {Categorizing} {Android} {Sources} and {Sinks}},
  year      = {2014},
  abstract  = {Today’s smartphone users face a security dilemma: many apps they install operate on privacy-sensitive data, although 
they might originate from developers whose trustworthiness is hard to judge. Researchers have addressed the problem with more and more sophisticated static and dynamic analysis tools as an aid to assess how apps use private user data. Those tools, however, rely on the manual configuration of lists of sources of sensitive data as well as sinks which might leak data to untrusted observers. Such lists are hard to come by. 
 
We thus propose SUSI, a novel machine-learning guided approach for identifying sources and sinks directly from the code of any Android API. Given a training set of hand-annotated sources and sinks, SUSI identifies other sources and sinks in the entire API. To provide more fine-grained information, SUSI further categorizes the sources (e.g., unique identifier, location information, etc.) and sinks (e.g., network, file, etc.). 
 
For Android 4.2, SUSI identifies hundreds of sources and sinks with over 92\% accuracy, many of which are missed by current information-flow tracking tools. An evaluation of about 11,000 malware samples confirms that many of these sources and sinks are indeed used. We furthermore show that SUSI can reliably classify sources and sinks even in new, previously unseen Android versions and components like Google Glass or the Chromecast API.},
  doi       = {10.14722/NDSS.2014.23039},
  file      = {Semantic Scholar Link:https\://www.semanticscholar.org/paper/A-Machine-learning-Approach-for-Classifying-and-and-Rasthofer-Arzt/33987e58b45755a6120905ce582fc9cbec434763:text/html;Full Text PDF:https\://pdfs.semanticscholar.org/5a8e/d3604393818fe1bca9396e55ea6bd320e49c.pdf:application/pdf},
}

@Book{Aho1986,
  author       = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  publisher    = {Reading, Mass. : Addison-Wesley Pub. Co.},
  title        = {Compilers, principles, techniques, and tools},
  year         = {1986},
  isbn         = {9780201100884},
  abstract     = {Bibliography: p. [752]-779; Includes index},
  collaborator = {{Internet Archive}},
  keywords     = {Compilers (Computer programs)},
  language     = {eng},
  url          = {http://archive.org/details/compilersprincip00ahoa},
  urldate      = {2021-02-15},
}

@Book{Thain2019,
  author    = {Thain, Douglas},
  publisher = {Lulu.com},
  title     = {Introduction to {Compilers} and {Language} {Design}},
  year      = {2019},
  isbn      = {9780359138043},
  month     = jul,
  note      = {Google-Books-ID: 5mVyDwAAQBAJ},
  abstract  = {A compiler translates a program written in a high level language into a program written in a lower level language. For students of computer science, building a compiler from scratch is a rite of passage: a challenging and fun project that offers insight into many different aspects of computer science, some deeply theoretical, and others highly practical. This book offers a one semester introduction into compiler construction, enabling the reader to build a simple compiler that accepts a C-like language and translates it into working X86 or ARM assembly language. It is most suitable for undergraduate students who have some experience programming in C, and have taken courses in data structures and computer architecture.},
  file      = {Google Books Link:https\://books.google.de/books?id=5mVyDwAAQBAJ:text/html},
  keywords  = {Computers / General},
  language  = {en},
}

@PhdThesis{Arzt2017PhD,
  author    = {Arzt, Steven},
  school    = {Technische Universität},
  title     = {Static {Data} {Flow} {Analysis} for {Android} {Applications}},
  year      = {2017},
  address   = {Darmstadt},
  abstract  = {Mobile phones have become important daily companions for millions of people which help to organize both their private and their professional lives. Having access to data such as the calendar or the address book anywhere, anytime, has become commonplace. Sensor data such as the phone's GPS location and accelerometer help users navigate through the physical world. Users can furthermore extend the functionality of their phone using small programs called apps from various developers and vendors in an open ecosystem. Undoubtedly, having all this data merged on a device that is always-on and always-connected and that can easily be extended with new software greatly improves user convenience. On the other hand, it also poses new questions with regard to privacy and security. Apps may misuse the data stored on the phone or obtained from the sensors to infringe upon the user's privacy. In fact, companies already now use location data and app usage statistics to build user profiles for the purpose of targeted advertisement. The user is oftentimes unaware of these data leaks originating from his phone and has little means for analyzing the actual behavior of a given app with regard to privacy.

Static data flow analysis has been proposed as a means for automatically enumerating the data flows inside a program. Still, either do not support Android's platform-specific semantics or fall short on precision, recall, or scalability. In this thesis, we therefore propose techniques for efficiently and precisely performing static data flow analysis on real-world binary-only Android apps with large code sizes. We present the FlowDroid tool and show that it can detect data leaks in popular apps such as Facebook, Paypal, and LinkedIn. The FlowDroid reports improve the user's digital sovereignty by allowing his to asses the behavior of the app before installing it on his device and thereby entrusting it with his personal data. We allow the user to verify which of his data leaves the device and how. On the DroidBench micro-benchmark suite, we show that FlowDroid achieves a precision of more than 87\% and a recall of over 84\%, thereby outperforming state-of-the-art tools from academia and industry. Additionally, FlowDroid has already been used as a building-block for many other works in the field.},
  copyright = {lediglich die vom Gesetz vorgesehenen Nutzungsrechte gemäß UrhG},
  file      = {Full Text PDF:https\://tuprints.ulb.tu-darmstadt.de/5937/7/Thesis.pdf:application/pdf},
  language  = {en},
  url       = {https://tuprints.ulb.tu-darmstadt.de/5937/},
  urldate   = {2021-01-28},
}

@InProceedings{Lerch2015,
  author    = {Johannes Lerch and Ben Hermann},
  booktitle = {Proceedings of the 4th {ACM} {SIGPLAN} International Workshop on State Of the Art in Program Analysis},
  title     = {Design your analysis: a case study on implementation reusability of data-flow functions},
  year      = {2015},
  month     = {jun},
  publisher = {{ACM}},
  doi       = {10.1145/2771284.2771289},
}

@InProceedings{Reps1995,
  author    = {Thomas Reps and Susan Horwitz and Mooly Sagiv},
  booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages - {POPL} {\textquotesingle}95},
  title     = {Precise interprocedural dataflow analysis via graph reachability},
  year      = {1995},
  publisher = {{ACM} Press},
  doi       = {10.1145/199448.199462},
}

@InCollection{Naeem2010,
  author    = {Nomair A. Naeem and Ond{\v{r}}ej Lhot{\'{a}}k and Jonathan Rodriguez},
  booktitle = {Lecture Notes in Computer Science},
  publisher = {Springer Berlin Heidelberg},
  title     = {Practical Extensions to the {IFDS} Algorithm},
  year      = {2010},
  pages     = {124--144},
  doi       = {10.1007/978-3-642-11970-5_8},
}

@Article{Arzt2014,
  author    = {Steven Arzt and Siegfried Rasthofer and Christian Fritz and Eric Bodden and Alexandre Bartel and Jacques Klein and Yves Le Traon and Damien Octeau and Patrick McDaniel},
  journal   = {{ACM} {SIGPLAN} Notices},
  title     = {{FlowDroid}},
  year      = {2014},
  month     = {jun},
  number    = {6},
  pages     = {259--269},
  volume    = {49},
  doi       = {10.1145/2666356.2594299},
  publisher = {Association for Computing Machinery ({ACM})},
}

@Article{Valleerai2004,
  author     = {Vallee-rai, Raja and Hendren, Laurie},
  title      = {Jimple: {Simplifying} {Java} {Bytecode} for {Analyses} and {Transformations}},
  year       = {2004},
  month      = jan,
  abstract   = {In this paper we present Jimple, a 3-address intermediaterepresentation that has been designed tosimplify analysis and transformation of Java bytecode.We motivate the need for a new intermediaterepresentation by illustrating several difficultieswith optimizing the stack-based Java bytecode directly.In general, these difficulties are due to thefact that bytecode instructions affect an expressionstack, and thus have implicit uses and definitions ofstack locations. We propose Jimple as an ...},
  file       = {ResearchGate Link:https\://www.researchgate.net/publication/243776080_Jimple_Simplifying_Java_Bytecode_for_Analyses_and_Transformations:},
  shorttitle = {Jimple},
}

@InProceedings{Bodden2012,
  author    = {Eric Bodden},
  booktitle = {Proceedings of the {ACM} {SIGPLAN} International Workshop on State of the Art in Java Program analysis - {SOAP} {\textquotesingle}12},
  title     = {Inter-procedural data-flow analysis with {IFDS}/{IDE} and Soot},
  year      = {2012},
  publisher = {{ACM} Press},
  doi       = {10.1145/2259051.2259052},
}

@InProceedings{Yan2017,
  author    = {Yan, X. and Ma, H. and Wang, Q.},
  booktitle = {2017 {IEEE} 9th {International} {Conference} on {Communication} {Software} and {Networks} ({ICCSN})},
  title     = {A static backward taint data analysis method for detecting web application vulnerabilities},
  year      = {2017},
  month     = may,
  note      = {ISSN: 2472-8489},
  pages     = {1138--1141},
  abstract  = {This paper addresses detecting taint-style vulnerabilities in PHP code. It extends classical taint-style model with an element called “cleans”, which is used to specify sanitation routines. Based on the new model, a static backward taint data analysis method is proposed to detecting taint-style vulnerabilities. This method includes four key steps, first of which is collecting sinks and constructing contexts, the second is backward tracing variables during a basic block, the third is tracing variables between blocks, and the last is tracing variables crossing function call. A tool called POSE implements this method and testing results show that the method is valid for detecting taint-style web application vulnerabilities.},
  doi       = {10.1109/ICCSN.2017.8230288},
  file      = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/stampPDF/getPDF.jsp?tp=&arnumber=8230288&ref=aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2RvY3VtZW50LzgyMzAyODg=:application/pdf},
  issn      = {2472-8489},
  keywords  = {data analysis, Internet, program diagnostics, programming, security of data, software tools, static backward taint data analysis method, taint-style web application vulnerabilities, classical taint-style model, POSE implements, PHP code, Web application vulnerabilities detection, taint-style vulnerabilities detection, Data analysis, Data models, Tools, Algorithm design and analysis, Reactive power, taint data analysis, PHP, web application, vulnerabilities},
}

@Book{Muchnick1997,
  author    = {Steven S. Muchnick},
  publisher = {Morgan Kaufmann},
  title     = {Advanced Compiler Design and Implementation},
  year      = {1997},
  isbn      = {1-55860-320-4},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl    = {https://dblp.org/rec/books/mk/Muchnick1997.bib},
  timestamp = {Mon, 05 Jan 2004 14:58:03 +0100},
}

@Book{Khedker2009,
  author     = {Khedker, Uday and Sanyal, Amitabha and Sathe, Bhaurao},
  title      = {Data {Flow} {Analysis}: {Theory} and {Practice}},
  year       = {2009},
  isbn       = {9780849332517},
  month      = jan,
  abstract   = {This work provides an in-depth treatment of data flow analysis technique. Apart from including interprocedural data flow analysis, this book is the first to extend detailed coverage of analysis beyond bit vectors. Supplemented by numerous examples, it equips readers with a combination of mutually supportive theory and practice, presenting mathematical foundations and including study of data flow analysis implementation through use of the GNU Compiler Collection (GCC). Readers can experiment with the analyses described in the book by accessing the authors web page, where they will find the source code of gdfa (generic data flow analyzer).},
  doi        = {10.1201/9780849332517},
  file       = {ResearchGate Link:https\://www.researchgate.net/publication/262493821_Data_Flow_Analysis_Theory_and_Practice:},
  journal    = {Data Flow Analysis: Theory and Practice},
  shorttitle = {Data {Flow} {Analysis}},
}

@Comment{jabref-meta: databaseType:bibtex;}
